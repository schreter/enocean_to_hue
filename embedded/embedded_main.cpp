/*
 * Copyright (C) 2018-2019 Ivan Schr√©ter (schreter@gmx.net)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * This copyright notice MUST APPEAR in all copies of the software!
 */

// This file is used for embedded version of the bridge running on ESP8266

#ifdef ARDUINO

#include <ESP8266WiFi.h>
#include <ESP.h>
#include <ArduinoOTA.h>

// user_config.hpp must be provided by the user, see user_config_example.hpp
#include "user_config.hpp"

// user_config_map.hpp must be generated by the user from user_config.conf using make_embedded_config.py
#include "user_config_map.hpp"

#include "enocean.hpp"
#include "enocean_serial_esp8266.hpp"
#include "debug.hpp"
#include "embedded_syslog.hpp"
#ifdef DIRECT_CONNECT
#include "hue_sensor_command_embedded.hpp"
#else
#define PROXY_CONNECT
#endif
#ifdef PROXY_CONNECT
extern "C" {
  #include "lwip/udp.h"
}
#endif

/// Debug activated
bool s_debug = false;

/// Get SSID directly (normally done like this).
const char* extract_ssid(const char* id) { return id; }

/// Get SSID via a function.
template<typename Fnc>
const char* extract_ssid(Fnc& f) { return f(); }

void setup_wifi()
{
  auto real_ssid = extract_ssid(ssid);
  delay(10);
  debug_stream::instance() << F("Connecting WiFi to ") << real_ssid << '\n';
  WiFi.begin(real_ssid, password);
}

void setup_ota()
{
  // Port defaults to 8266
  ArduinoOTA.setPort(8266);

  // Hostname defaults to esp8266-[ChipID]
  ArduinoOTA.setHostname("enocean-hue");

  // No authentication by default
  ArduinoOTA.setPassword(ota_password);

  // Password can be set with it's md5 value as well
  // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3
  // ArduinoOTA.setPasswordHash("21232f297a57a5a743894a0e4a801fc3");

  ArduinoOTA.onStart([]() {
    const __FlashStringHelper* type;
    if (ArduinoOTA.getCommand() == U_FLASH) {
      type = F("sketch");
    } else { // U_SPIFFS
      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      type = F("filesystem");
    }

    debug_stream::instance() << F("OTA update: starting to update ") << type << '\n';
  });
  ArduinoOTA.onEnd([]() {
    debug_stream::instance() << F("\nOTA update: done\n");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    debug_stream::instance() << F("OTA update: progress ") << (progress * uint32_t(100) / total) << '\r';
  });
  ArduinoOTA.onError([](ota_error_t error) {
    auto& str = debug_stream::instance();
    str << F("\nOTA update error ") << error << F(": ");
    switch (error) {
      case OTA_AUTH_ERROR: str << F("authorization failed\n"); break;
      case OTA_BEGIN_ERROR: str << F("begin failed\n"); break;
      case OTA_CONNECT_ERROR: str << F("connet failed\n"); break;
      case OTA_RECEIVE_ERROR: str << F("receive failed\n"); break;
      case OTA_END_ERROR: str << F("end failed\n"); break;
      default: str << F("unknown\n"); break;
    }
  });
  ArduinoOTA.begin();
  debug_stream::instance() << F("OTA ready\n");
}

void setup()
{
  pinMode(LED_BUILTIN, OUTPUT);     // Initialize the LED_BUILTIN pin as an output
#ifdef ENOCEAN_USE_SERIAL0
  // Use Serial0 for EnOcean serial (HW serial, since we need 57600 baud input)
  Serial.begin(57600);
  // Map RX/TX to pins D7/D8 (D8 w/ 10k pulldown)
  Serial.swap();
  // Debug serial, TX on D4, connected to TX pin for debug via USB serial adapter
  // Setting TX pin to input allows connecting D4 to TX to get debug output
  // via USB console.
  pinMode(TX, INPUT);
  Serial1.begin(115200);
  Serial1.println();
#else
  Serial.begin(115200);
  Serial.println();
#endif
  //setup_wifi();
  syslog_begin(syslog_host, syslog_port);
  openlog("enocean-hue", LOG_CONS, LOG_USER);
}

long next_led(long current_time, long delta)
{
  current_time += delta;
  if (current_time == 0)
    current_time = 1;
  return current_time;
}

long set_led(long current_time, long delta)
{
  digitalWrite(LED_BUILTIN, LOW); // LOW is on
  return next_led(current_time, delta);
}

void loop()
{
  static bool connected = true;
  static long led_off_time = 0;
  static long led_on_time = 0;
  static long last_dot_time = millis();
  static uint32_t total_event_count = 0;
#ifdef DIRECT_CONNECT
  static hue_sensor_command_embedded command(bridge, api_key, sensor_id);
  static uint32_t our_event_count = 0;
#endif
#ifdef PROXY_CONNECT
  static udp_pcb* master_conn = nullptr;
#endif
  static enocean_serial_esp serial(
      [](const enocean_event& event) {
        led_off_time = set_led(millis(), 100);
        // event received, map to external ID for the bridge and push it
        uint32_t addr = 0;
        int8_t button = 0;
        switch (event.erp1.event_type) {
          case enocean_erp1_type::CONTACT:
            addr = event.erp1.contact_event.sender.raw();
            button = event.erp1.contact_event.is_closed() ? 1 : 0;
            break;
          case enocean_erp1_type::SWITCH:
            addr = event.erp1.switch_event.sender.raw();
            button = event.erp1.switch_event.button_id();
            break;
        }
        ++total_event_count;
        if (s_debug)
          debug_stream::instance() << F("Received EnOcean event, addr ") <<
              showbase << hex << addr << dec << F(", button ") << button <<
              F(", index ") << total_event_count;
#ifdef DIRECT_CONNECT
        auto id = map_action(addr, button);
        auto group = id >> 24;
        id &= 0xffffff;
        if (group == command.get_group_id())
          ++our_event_count;
        syslog_P(LOG_INFO, PSTR("EnOcean event, addr %lx, button %d => ID %ld@%ld/%ld, RSSI -%u, index %lu/%lu"),
                 addr, button, id, group, command.get_group_id(), event.erp1.contact_event.subtel[0].dbm,
                our_event_count, total_event_count);
        if (id) {
          if (s_debug)
            debug_stream::instance() << F(" => action ") << id << '@' << group << '?' << command.get_group_id() << '\n';
          command.post(id, group);
        } else {
          if (s_debug)
            debug_stream::instance() << F(" => no known action\n");
        }
#endif
#ifdef PROXY_CONNECT
        if (!master_conn) {
          // prepare UDP connection
          master_conn = udp_new_ip_type(IPADDR_TYPE_V4);
          if (!master_conn) {
            debug_stream::instance() << F("Proxy: cannot allocate UDP socket\n");
          } else {
            auto err = udp_bind(master_conn, IP_ADDR_ANY, master_port);
            if (err != ERR_OK) {
              debug_stream::instance() << F("Proxy: cannot bind local side of UDP socket, err=") << int32_t(err) << '\n';;
              udp_remove(master_conn);
              master_conn = nullptr;
            } else {
              uint32_t ip_addr = master;
              err = udp_connect(master_conn, reinterpret_cast<const ip_addr_t*>(&ip_addr), master_port);
              if (err != ERR_OK) {
                debug_stream::instance() << F("Proxy: cannot bind remote side of UDP socket, err=") << int32_t(err) << '\n';;
                udp_remove(master_conn);
                master_conn = nullptr;
              }
            }
          }
        }
        if (master_conn) {
          auto len = event.hdr.total_size() + sizeof(event.hdr);
          auto p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
          if (!p) {
            debug_stream::instance() << F("Proxy: cannot allocate UDP buffer\n");
          } else {
            pbuf_take(p, &event, len);
            auto err = udp_send(master_conn, p);
            if (err != ERR_OK) {
              debug_stream::instance() << F("Proxy: cannot send UDP packet, err=") << int32_t(err) << '\n';;
              udp_remove(master_conn);
              master_conn = nullptr;
            }
            pbuf_free(p);
          }
        }

        syslog_P(LOG_INFO, PSTR("EnOcean event, addr %lx, button %d, RSSI -%u"),
                 addr, button, event.erp1.contact_event.subtel[0].dbm);
#endif
      }
    );


  ESP.wdtFeed();
  long time = millis();
  if (WiFi.status() != WL_CONNECTED)
  {
    if (connected) {
      debug_stream::instance() << F("\nWiFi disconnected\n");
      connected = false;
      led_off_time = set_led(time, 100);
      last_dot_time = time;
      setup_wifi();
    }
  } else if (!connected) {
    auto ip = WiFi.localIP();
    auto real_ssid = extract_ssid(ssid);
    debug_stream::instance() << F("\nWiFi connected, IP address: ") <<
        int(ip[0]) << '.' << int(ip[1]) << '.' << int(ip[2]) << '.' << int(ip[3]) <<
        F(", RSSI=") << WiFi.RSSI() << F(", SSID=") << real_ssid << '\n';
#ifdef DIRECT_CONNECT
    // Use last octet of IP as group ID.
    command.set_group_id(ip[3]);
#endif
#ifdef PROXY_CONNECT
    if (master_conn)
      udp_remove(master_conn);
    master_conn = nullptr;
#endif
    digitalWrite(LED_BUILTIN, HIGH);
    syslog_P(LOG_INFO, PSTR("EnOcean WiFi connected, RSSI=%ld, SSID=%s"), WiFi.RSSI(), real_ssid);
    led_off_time = led_on_time = 0;
    connected = true;
    setup_ota();
  }

  if (led_off_time && (time - led_off_time >= 0)) {
    digitalWrite(LED_BUILTIN, HIGH);
    led_off_time = 0;
    if (!connected) {
      // blink with 100ms durig WiFi connection
      led_on_time = next_led(time, 50);
      led_off_time = next_led(time, 100);
    }
  }
  if (led_on_time && (time - led_on_time >= 0)) {
    digitalWrite(LED_BUILTIN, LOW);
    led_on_time = 0;
  }

  if (!connected) {
    if (time - last_dot_time >= 500) {
      debug_stream::instance() << '.';
      last_dot_time = time;
    }
    return; // no point doing anything else if we have no connection
  }

  // now process events
  serial.poll();
#ifdef DIRECT_CONNECT
  command.poll();
#endif
  ArduinoOTA.handle();
}

#endif
